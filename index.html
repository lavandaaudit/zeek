<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>IBONIRIUM · COSMOS TERRARIUM · EXP‑03 · Галактичний Лабіринт</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html, body {
  width:100%; height:100%;
  background:#000;
  overflow:hidden;
}
canvas { position:fixed; inset:0; }
#sensors {
  position:fixed;
  left:0; right:0; bottom:0;
  height:140px;
  pointer-events:none;
}
</style>
</head>
<body>
<canvas id="stars"></canvas>
<canvas id="cosmos"></canvas>
<canvas id="sensors"></canvas>

<script>
// CANVAS
const starCanvas = document.getElementById('stars');
const cosmosCanvas = document.getElementById('cosmos');
const sensorCanvas = document.getElementById('sensors');
const sctx = starCanvas.getContext('2d');
const cctx = cosmosCanvas.getContext('2d');
const scx = sensorCanvas.getContext('2d');

function resize(){
  starCanvas.width = cosmosCanvas.width = sensorCanvas.width = innerWidth;
  starCanvas.height = cosmosCanvas.height = innerHeight;
  sensorCanvas.height = 140;
}
addEventListener('resize', resize); resize();

// Глибокі зірки (фон)
const stars = Array.from({length:450},()=>({x:Math.random(),y:Math.random(),z:Math.random()*0.9+0.1}));
function drawStars(){
  sctx.clearRect(0,0,starCanvas.width,starCanvas.height);
  stars.forEach(st=>{
    st.y += 0.00003 * st.z; // ще повільніше
    if(st.y>1) st.y=0;
    sctx.globalAlpha = 0.15 + st.z*0.35;
    sctx.fillStyle = st.z > 0.6 ? "#fff" : (st.z > 0.3 ? "#ccd" : "#88f");
    sctx.beginPath();
    sctx.arc(st.x*starCanvas.width, st.y*starCanvas.height, st.z*1.4, 0, Math.PI*2);
    sctx.fill();
  });
  sctx.globalAlpha=1;
}

// NOAA (залишив для сенсорів)
let solarFactor = 1;
let solarSSN = 0;
let activity = 0;

async function updateSolar(){
  try{
    const r = await fetch('https://services.swpc.noaa.gov/json/solar-cycle/predicted-solar-cycle.json');
    const d = await r.json();
    const l = d[d.length-1];
    solarSSN = l.predicted_ssn;
    solarFactor = Math.min(4, 0.7 + solarSSN/100);
    activity = solarFactor * (0.6 + Math.random()*0.4);
  }catch(e){
    solarFactor = 1.2;
    activity = 1.8;
  }
}
updateSolar();
setInterval(updateSolar, 1800000);

// Галактики (колишні поля)
class Galaxy {
  constructor(x,y){
    this.cx = x;
    this.cy = y;
    this.growth = 0;
    this.maxGrowth = 18 + Math.random()*22;
    this.offset = Math.random();
    this.dir = Math.random()<0.5 ? 1 : -1;
    this.speed = 0.00008 + Math.random()*0.00012; // значно повільніше
    this.hue = Math.random()*360;
    this.chaosPoints = Array.from({length:7},()=>({x:(Math.random()-0.5)*40, y:(Math.random()-0.5)*40}));
  }
  grow(){
    if(this.growth < this.maxGrowth) this.growth += 0.008 * solarFactor; // повільніше зростання
    this.offset += this.dir * this.speed;
    if(this.offset>1) this.offset-=1;
    if(this.offset<0) this.offset+=1;
  }
  draw(){
    const breath = 1 + Math.sin(Date.now()*0.0004 + this.offset*Math.PI)*0.025;
    const steps = Math.min(this.growth, this.maxGrowth)*40;
    const alpha = 0.4 + this.growth*0.015;

    cctx.globalAlpha = alpha;
    cctx.lineWidth = 1.1 + this.growth*0.08;

    for(let arm=0; arm<4; arm++){ // кілька спіральних рукавів
      cctx.strokeStyle = `hsla(${this.hue + arm*90 + Math.sin(Date.now()*0.0001)*30}, 80%, 65%, ${0.5 + arm*0.1})`;
      cctx.beginPath();
      for(let i=0; i<=steps; i++){
        const t = i/steps;
        let radius = t*90*breath*(1 + activity*0.25);
        this.chaosPoints.forEach(p=>{
          radius += Math.sin(i*0.4 + p.x + Date.now()*0.0003 + arm*3)*8;
        });
        const angle = t*Math.PI*6 + arm*Math.PI*0.5 + Math.sin(i*0.2 + this.offset*4)*0.6;
        const x = this.cx + Math.cos(angle)*radius;
        const y = this.cy + Math.sin(angle)*radius;
        if(i===0) cctx.moveTo(x,y);
        else cctx.lineTo(x,y);
      }
      cctx.stroke();
    }

    // Ядро галактики
    const coreX = this.cx + Math.cos(this.offset*Math.PI*2)*this.growth*3;
    const coreY = this.cy + Math.sin(this.offset*Math.PI*2)*this.growth*3;
    cctx.fillStyle = `hsla(${this.hue}, 90%, 80%, 0.9)`;
    cctx.beginPath();
    cctx.arc(coreX, coreY, 3 + this.growth*0.4, 0, Math.PI*2);
    cctx.fill();

    cctx.globalAlpha = 1;
  }
}

const galaxies = Array.from({length:18},()=>new Galaxy(
  Math.random()*cosmosCanvas.width,
  Math.random()*cosmosCanvas.height*0.88 + cosmosCanvas.height*0.06
));

// Маленькі кораблі та супутники
class Drifter {
  constructor(){
    this.x = Math.random()*cosmosCanvas.width;
    this.y = Math.random()*cosmosCanvas.height;
    this.angle = Math.random()*Math.PI*2;
    this.speed = 0.08 + Math.random()*0.15;
    this.size = 1.5 + Math.random()*2.5;
    this.type = Math.random() < 0.5 ? 'ship' : 'probe';
    this.trail = [];
  }
  update(){
    this.angle += (Math.random()-0.5)*0.004;
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;

    if(this.x < 0 || this.x > cosmosCanvas.width) this.angle = Math.PI - this.angle;
    if(this.y < 0 || this.y > cosmosCanvas.height) this.angle = -this.angle;

    this.trail.push({x:this.x, y:this.y});
    if(this.trail.length > 18) this.trail.shift();
  }
  draw(){
    // слід
    cctx.globalAlpha = 0.3;
    cctx.strokeStyle = this.type === 'ship' ? '#88ffff' : '#ff88cc';
    cctx.lineWidth = this.size*0.6;
    cctx.beginPath();
    this.trail.forEach((p,i)=>{
      if(i===0) cctx.moveTo(p.x, p.y);
      else cctx.lineTo(p.x, p.y);
    });
    cctx.stroke();

    // сам об'єкт
    cctx.globalAlpha = 0.9 + Math.sin(Date.now()*0.003 + this.x)*0.1;
    cctx.fillStyle = this.type === 'ship' ? '#aaffff' : '#ffccff';
    cctx.beginPath();
    cctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    cctx.fill();

    // маленький блиск
    cctx.fillStyle = '#ffffff';
    cctx.beginPath();
    cctx.arc(this.x + Math.cos(Date.now()*0.005)*3, this.y + Math.sin(Date.now()*0.005)*3, 1, 0, Math.PI*2);
    cctx.fill();

    cctx.globalAlpha = 1;
  }
}

const drifters = Array.from({length:12},()=>new Drifter());

// Зв'язки між галактиками (космічні мости / нитки)
function drawLinks(){
  cctx.strokeStyle = 'rgba(140,180,255,0.08)';
  cctx.lineWidth = 0.7;
  for(let i=0; i<galaxies.length; i++){
    for(let j=i+1; j<galaxies.length; j++){
      const g1 = galaxies[i], g2 = galaxies[j];
      const dx = g2.cx - g1.cx;
      const dy = g2.cy - g1.cy;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < 500){
        cctx.beginPath();
        const chaos = Math.sin(Date.now()*0.0006 + i*j)*8;
        cctx.moveTo(g1.cx+chaos, g1.cy+chaos);
        cctx.lineTo(g2.cx+chaos, g2.cy+chaos);
        cctx.stroke();
      }
    }
  }
}

// Сенсори (без тексту)
function drawSensors(){
  scx.clearRect(0,0,sensorCanvas.width,sensorCanvas.height);
  const baseY = 110;
  scx.strokeStyle = 'rgba(120,255,180,0.12)';
  scx.beginPath(); scx.moveTo(0,baseY); scx.lineTo(sensorCanvas.width,baseY); scx.stroke();

  scx.fillStyle = 'rgba(255,220,140,0.7)';
  scx.beginPath();
  scx.arc(80, baseY-40, 9 + solarFactor*5, 0, Math.PI*2);
  scx.fill();

  scx.strokeStyle = 'rgba(160,220,255,0.7)';
  scx.beginPath();
  scx.moveTo(160, baseY);
  scx.lineTo(160, baseY - activity*35);
  scx.stroke();

  const now = new Date();
  const t = Math.min(1, (now - START_DATE)/(STOP_DATE - START_DATE));
  scx.strokeStyle = 'rgba(200,200,255,0.55)';
  scx.beginPath();
  scx.arc(260, baseY, 30, -Math.PI/2, -Math.PI/2 + t*Math.PI*2);
  scx.stroke();
}

// Дати
const START_DATE = new Date('2026-01-01');
const STOP_DATE = new Date('2026-12-13');

function loop(){
  drawStars();
  drawSensors();

  if(new Date() < STOP_DATE){
    cctx.clearRect(0,0,cosmosCanvas.width,cosmosCanvas.height);

    galaxies.forEach(g=>{ g.grow(); g.draw(); });
    drawLinks();

    drifters.forEach(d=>{
      d.update();
      d.draw();
    });
  }

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
